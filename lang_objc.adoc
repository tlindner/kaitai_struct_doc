= Kaitai Struct: Objective-C / Cocoa notes
:source-highlighter: coderay

== Invocation

=== Quick start

Parsing from local file:

[source,objective-c]
----
#import <kaitai/kaitaistream.h>

NSURL *fileURL = [NSURL fileURLWithPath:@"path/to/local/file.dat"];
KSStream *s = [KSStream streamWithURL:fileURL];
example_t *data = [example_t initWithStream:s];

----

Parsing from `NSData`:

[source,objective-c]
----
#include <kaitai/kaitaistream.h>

NSData *buf = ???; /* data from somewhere */
KSStream *s = [KSStream streamWithData:buf];
example_t *data = [example_t initWithStream:s];
----

=== Auto-read

By default, invoking constructor with a stream argument assumes that
you want to run parsing process and populate object's fields with the
data read from the stream:

[source,objective-c]
----
example_t data(&ks);
data.some_attribute(); // already populated and available
----

However, sometimes you want more control and want to trigger that
process manually. In that case, you can supply `--no-auto-read`
argument for kaitai-struct-compiler, and you'll have to trigger
reading manually using `_read()` invocation:

[source,objective-c]
----
example_t *data = [example_t streamWith:ks];
data.some_attribute; // not yet populated, may contain random garbage
[data _read];
data.some_attribute; // populated and available
----

There are several reasons why you'd want to separate object creation
and object population:

* Obviously, if you're using read-write mode with the intent to
  populate the object manually and call `_write()` afterwards to
  serialize it. In this use-case, you probably won't call `_read` at
  all.
* You want to reuse the same object and thus want to repeatedly call
  `_read()` on several times manually.


== Type mapping

Mapping KS types to Cocoa calsses is pretty straight-forward:

[cols=",",options="header",]
|==========================
|`type` |Cocoa Class
|no type |NSData
|`u1` |NSNumber
|`u2` |NSNumber
|`u4` |NSNumber
|`u8` |NSNumber
|`s1` |NSNumber
|`s2` |NSNumber
|`s4` |NSNumber
|`s8` |NSNumber
|`str`, `strz` |NSString
|Array |NSArray
|ENUM |NSDictionary
|==========================

=== ENUMs

C enums are not introspective at runtime. Becuase of this, they are not used.
I felt it was important to retain the name in addition to the value. This means
enum types are a NSDictionary with two keys: @"value", and @"enum".

@"value" return an NSNumber with the value.

@"enum" returns an NSString with the human readable name or "unknown".

Each Kaitai Struct class that defines a enum includes a property to access
a NSDictionary of all defined names and values.

[source,yaml]
----
meta:
  id: identifier
  endian: le
seq:
  - id: pet_1
    type: u4
    enum: animal
enums:
  animal:
    4: dog
    7: cat
    12: chicken
----

 The class identifier_t will include a property called _animal. That property
 will return an NSDictionary that looks like this:

 [source,objective-c]
 ----
 @{@"dog" : @(4), @"cat" : @(7), @"chicken" : @(12)}
 ----

=== Switch Types

Switch types can store different object in a property. Becuase of this the, in
header file for this struct, the property will be defined as having a type of
(KSStruct *). For example:

[source,yaml]
----
meta:
  id: cast_nested
seq:
  - id: opcodes
    type: opcode
    repeat: eos
instances:
  opcodes_first:
    value: opcodes[0].body.as<opcode::strval>
types:
  opcode:
    seq:
      - id: code
        type: u1
      - id: body
        type:
          switch-on: code
          cases:
            73: intval
            83: strval
    types:
      intval:
        seq:
          - id: value
            type: u1
      strval:
        seq:
          - id: value
            type: strz
            encoding: ASCII
----
The type of opcode_first can either have a type of (intval_cast_nested_t *) or
(str_value_cast_nested_t *) so in the header file with type of (KSStruct *). You
will need to type caste it to the proper type to access it's properties.
