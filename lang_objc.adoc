= Kaitai Struct: Objective-C / Cocoa notes
:source-highlighter: coderay

== Invocation

=== Quick start

Parsing from local file:

[source,objective-c]
----
#import <kaitai/kaitaistream.h>
#import "example.h"

NSURL *fileURL = [NSURL fileURLWithPath:@"path/to/local/file.dat"];
KSStream *s = [KSStream streamWithURL:fileURL];
KSExample *data = [KSExample structWithStream:s];

----
Parsing from `NSData`:

[source,objective-c]
----
#include <kaitai/kaitaistream.h>
#import "example.h"

NSData *buf = ???; /* data from somewhere */
KSStream *s = [KSStream streamWithData:buf];
KSExample *data = [KSExample structWithStream:s];
----
=== Auto-read

By default, invoking constructor with a stream argument assumes that
you want to run parsing process and populate object's fields with the
data read from the stream:
[source,objective-c]
----
KSExample *data = [KSExample structWithStream:s];
NSLog( @"attribute: %@", data.some_attribute) ; /* already populated and available */
----
However, sometimes you want more control and want to trigger that
process manually. In that case, you can supply `--no-auto-read`
argument for kaitai-struct-compiler, and you'll have to trigger
reading manually using `_read()` invocation:
[source,objective-c]
----
KSExample *data = [KSExample streamWith:ks];
data.some_attribute; /* not yet populated, may contain random garbage */
[data _read];
data.some_attribute; /* populated and available */
----
There are several reasons why you'd want to separate object creation
and object population:

* Obviously, if you're using read-write mode with the intent to
  populate the object manually and call `_write()` afterwards to
  serialize it. In this use-case, you probably won't call `_read` at
  all. (Note: _write not implemented yet)
* You want to reuse the same object and thus want to repeatedly call
  `_read()` on several items manually.
=== Class Names
The class names use the KS namespace and follow upper camel case. This means the following
ksy file:
[source,yaml]
----
meta:
  id: example
  endian: le
seq:
  - id: pet_1
    type: u4
----
will produce a class name of "KSExample". Usertype classes will contain the name of the
parent as well. The following ksy:
[source,yaml]
----
meta:
  id: example
  endian: le
seq:
  - id: pet_1
    type: part_foo
types:
  part_foo:
    seq:
      - id: bar1
      type: u1
      - id: bar2
      type: u1
----
The class of pet_1 will be KSPartFoo_Example.
=== Type mapping
Mapping KS types to Cocoa calsses is pretty straight-forward:
[cols=",",options="header",]
|==========================
|`type` |Cocoa Class
|no type |NSData
|`u1` |NSNumber
|`u2` |NSNumber
|`u4` |NSNumber
|`u8` |NSNumber
|`s1` |NSNumber
|`s2` |NSNumber
|`s4` |NSNumber
|`s8` |NSNumber
|`str`, `strz` |NSString
|Array |NSArray
|ENUM |NSDictionary
|==========================
=== ENUMs
C enums are not introspective at runtime. Becuase of this, they are not used.
I felt it was important to retain the name in addition to the value. This means
enum types are a NSDictionary with two keys: @"value", and @"enum".

@"value" return an NSNumber with the value.

@"enum" returns an NSString with the human readable name or "unknown".

Each Kaitai Struct class that defines an enum includes a property to access
a NSDictionary of all defined names and values.

[source,yaml]
----
meta:
  id: identifier
  endian: le
seq:
  - id: pet_1
    type: u4
    enum: animal
enums:
  animal:
    4: dog
    7: cat
    12: chicken
----

The class KSIdentifer will include a property called _animal. That property
will return an NSDictionary that looks like this:

[source,objective-c]
----
@{@"dog" : @(4), @"cat" : @(7), @"chicken" : @(12)}
----

=== Switch Types

Switch types can store different objects in a property. In the header file for this
struct, the property will be defined as having a type of (KSStruct *). For example:

[source,yaml]
----
meta:
  id: cast_nested
seq:
  - id: opcodes
    type: opcode
    repeat: eos
instances:
  opcodes_first:
    value: opcodes[0].body.as<opcode::strval>
types:
  opcode:
    seq:
      - id: code
        type: u1
      - id: body
        type:
          switch-on: code
          cases:
            73: intval
            83: strval
    types:
      intval:
        seq:
          - id: value
            type: u1
      strval:
        seq:
          - id: value
            type: strz
            encoding: ASCII
----
The type of opcode_first can either be (KSIntval_CastNested *) or
(KSStrval_CastNested *). In the header file it will have the type of (KSStruct *). You
will need to typecast it to the proper type to access it's properties.
=== Custom processing
In this example ksy:
[source,yaml]
----
meta:
  id: process_custom
seq:
  - id: buf1
    size: 5
    process: my_custom_fx(7, true, [0x20, 0x30, 0x40])
  - id: buf2
    size: 5
    process: nested.deeply.custom_fx(7)
  - id: key
    type: u1
  - id: buf3
    size: 5
    process: my_custom_fx(key, false, [0x00])
----
You will see a custom process defined that takes three parameters. You must provide an
Objective-C class that provides this functionality.

The class name should exactly match what is specified in the ksy. For the example above
your header file will look like this:
[source,objective-c]
----
#ifndef MY_CUSTOM_FX_H_
#define MY_CUSTOM_FX_H_

#import <Cocoa/Cocoa.h>

@interface my_custom_fx : NSObject

- (instancetype) initWith:(int)p_key,...;
- (NSData *)decode:(NSData *)src;

@property int key;
@property BOOL flag;
@property (strong) NSData *some_bytes;

@end

#endif  // MY_CUSTOM_FX_H_
----
Two methods are specified, initWith: and decode:. The decode: method will accept the
data and return the processed output. InitWith: is a VARARG method that accepts all
the parameters. Here is the Objective-C code to handle the above:

[source,objective-c]
----
- (instancetype) initWith:(int)p_key,...
{
    self = [super init];
    if (self) {
        va_list args;
        va_start(args, p_key);
        self.key = p_key;
        self.flag = va_arg(args, int); /* promoted from BOOL */
        self.some_bytes = va_arg(args, NSData*);
        va_end(args);

        self.key = self.flag ? self.key : -self.key;
    }
    return self;
}
----
=== Credit
The Objective-C runtime library and Kaitai Struct code generator was written by Tim
Lindner (tlindner@macmess.org) around May 2019.
